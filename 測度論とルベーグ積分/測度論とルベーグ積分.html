<!DOCTYPE html>
<html>
<head>
<title>測度論とルベーグ積分.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>
<link rel="stylesheet" href="file:///d%3A/%E3%83%9E%E3%83%BC%E3%82%AF%E3%83%80%E3%82%A6%E3%83%B3/practice/github-markdown.css" type="text/css">
<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://yukimaru77.github.io/practice/github-markdown.css">
<style>
.markdown-body {
box-sizing: border-box;
min-width: 200px;
max-width: 980px;
margin: 0 auto;
padding: 45px;
}

@media (max-width: 767px) {
.markdown-body {
  padding: 15px;
}
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
      ]
    });
  });
  elements = document.getElementsByTagName("h2");
  console.log(elements)

</script>
</head>
<body>
  <article class="markdown-body">
<h1 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E7%A9%8D%E5%88%86%E5%85%A5%E9%96%80">ルベーグ積分入門</h1>
<h2 id="%E6%99%AE%E9%80%9A%E3%81%AE%E7%A9%8D%E5%88%86%E3%83%AA%E3%83%BC%E3%83%9E%E3%83%B3%E7%A9%8D%E5%88%86">普通の積分(リーマン積分)</h2>
<p>我々が普段使っている積分は <strong>リーマン積分</strong> と呼ばれている。詳細は<a href="https://www1.econ.hit-u.ac.jp/kawahira/courses/lebesgue.pdf">こちら</a>で見てほしいが、簡単にいうと、リーマン積分とはリーマン和の極限として定義される。</p>
<p>リーマン和$\sum(f,Δ,Δ^\ast)$は関数$f:[a,b]→R$と区間$[a,b]$の分割$Δ=\lbrace x_1,x_2,\cdots,x_n\rbrace$と分割$Δ$の代表値$Δ^\ast=\lbrace x_1^\ast,x_2^\ast,\cdots,x_n^\ast\rbrace$を用いて</p>
<p>$$
\sum(f,Δ,Δ^\ast):=\sum_{k=1}^nf(x_k^\ast)(x_k-x_{k-1})
$$</p>
<p>と定義される。さらに$|Δ|:=max(x_k-x_{k-1})$とするとこれの極限を用いてリーマン積分は <strong>リーマン和の上限と下限が同じ値に収束するならば</strong> 収束値Aを用いて</p>
<p>$$
\int_a^bf(x)dx:=A=\lim_{|Δ|→0}\sum(f,Δ,Δ^\ast)
$$</p>
<p>と定義される。重要なのは <strong>リーマン和の上限と下限が同じ値に収束するならば</strong> という点である。つまりどのような代表値に依存せず収束することが条件である。この性質より例えば有理数なら1、無理数なら0といった関数(ディレクレ関数という)は代表の幅を限りなく0に近づけても代表値を有理数にするのか無理数にするのかで上限と下限が一致しないため積分不可能。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E7%A9%8D%E5%88%86%E3%81%AE%E6%A6%82%E8%AA%AC">ルベーグ積分の概説</h2>
<p>リーマン和ならぬルベーグ和は関数$f:[a,b]→R$と区間$[a,b]$の値域の分割$Δ=\lbrace y_1,y_2,\cdots,y_n\rbrace$に対し集合$A_K(K=1,2,\cdots ,m)$を
$$
A_K:=\lbrace x\in [a,b]|f(x)\in [y_{k-1},y_k)\rbrace
$$</p>
<p>とし、集合の長さ$μ(A_K)$を適切に定義できればルベーグ和を
$$
\sum_{K=1}^ny_k\cdot μ(A_k)
$$
とすればリーマン和の近似を与えるだろう。これがルベーグ積分の気持ちである。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E5%A4%96%E6%B8%AC%E5%BA%A6">ルベーグ外測度</h2>
<p>ルベーグ積分はリーマン積分の拡張として定義したいのだから、期待する性質は、</p>
<ol>
<li>閉区間[a,b]の長さμ([a,b])=b-a</li>
<li>互いに素な集合の列$A_n$に対し、$μ(\bigcup_n A_n)=\sum_nμ(A_n)$</li>
<li>集合Aと数xに対し$A+x:=\lbrace a+x|a\in A\rbrace$に対し、$μ(A+x)=μ(A)$</li>
</ol>
<p>を満たしてほしいのは自然だろう。互いに素な集合の列としたが、例えば$A_3$以降は$\varnothing$とすれば$μ(A_1\cup A_2)=μ(A_1)+μ(A_2)$となる。</p>
<p>ここで任意の冪集合の要素$A\in \mathfrak{P}(R^n)$に対し、ルベーグ外測度$μ^\ast(A)$を以下のように定義する。ただし、まだこの段階では条件2は満たさない。</p>
<p>$$
μ^\ast:\mathfrak{P}(R^n)→R,\quad μ^\ast(A):=inf(\sum_{n=1}^∞|I_n|)
$$
ただし$I_n$はそれぞれ直方体$I_n:=\prod_{i=1}^n(a_i,b_i]$であり、その体積$|I_n|$は$|I_n|:=\prod_{i=1}^n(b_i-a_i)$でありさらに$I_n$からなる集合はAを被膜している。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E5%A4%96%E6%B8%AC%E5%BA%A6%E3%81%AE%E6%80%A7%E8%B3%AA">ルベーグ外測度の性質</h2>
<p>ルベーグ外測度は以下の性質を満たす。</p>
<ol>
<li>Aが空集合$\varnothing$や1点集合、1点集合の可算個の和集合なら$μ^\ast(A)=0$。この時、Aを <strong>零集合</strong> という。ただし非可算個の和には成り立たないので注意。</li>
<li>$A\subset B$ならば、$μ^\ast(A)\leqq μ^\ast(B)$</li>
<li>可算劣加法性(σ-劣加法性)を満たす。R の部分集合からなる列$A_n$に対し、$μ^\ast(\bigcup_n A_n)\leqq\sum_nμ^\ast(A_n)$</li>
<li>区間 [a, b]，[a, b)，(a, b]，(a, b) の外測度はすべて b − a</li>
</ol>
<p>ここで性質3について、列の話つまり <strong>可算個</strong> についての話であって有限個の話や非可算個の話はしていないので注意。</p>
<ol start="5">
<li>性質3において$A_n=\varnothing(3\leqq N )$とすれば任意の$A_1,A_2$に対し$μ^\ast(A_1\cup A_2)\leqqμ^\ast(A_1)+μ^\ast(A_2)$</li>
</ol>
<p>ここで性質5について、等号成立条件は$A_1\cap A_2=\varnothing$ではないので注意。要は$A_1\cap A_2=\varnothing$でも$μ^\ast(A_1\cup A_2)&lt;μ^\ast(A_1)+μ^\ast(A_2)$  <strong>となる場合が存在する。</strong> ただし、やはりそれでは性質がよろしくないので互いに素の時、性質3及び性質5で等号をなりたたせる事が目標となる。つまりルベーグ外測度の項で述べた2つめの条件のことである。</p>
<h2 id="%E5%8F%AF%E6%B8%AC%E9%9B%86%E5%90%88">可測集合</h2>
<p>$A_1\cap A_2=\varnothing$の時、$μ^\ast(A_1\cup A_2)=μ^\ast(A_1)+μ^\ast(A_2)$を成り立たせるために、 <strong>可測集合</strong> を考える。</p>
<p>集合$E\subset R^n$が <strong>可測集合</strong> であるとは、任意の$F\subset R^n$に対し
$$
μ^\ast(F\cap E)+μ^\ast(F\cap E^c) =μ^\ast(F)
$$
を満たすことを言う。 <strong>可測集合全体からなる集合</strong> を$\mathfrak{M}$と今後表す。</p>
<p>例えば、$A_1=F\cap E,A_2=F\cap E^c$とすれば$A_1\cap A_2=\varnothing$かつ、$μ^\ast(A_1\cup A_2)=μ^\ast(A_1)+μ^\ast(A_2)$になるし、</p>
<p>新たに可測集合$A'$を用いて$A'_1:=A_1,A'_2:=A_2\cap A',A'_3:=A_2\cap(A')^c,$と置けば$μ^\ast(A_1'\cup A_2'\cap A_3')=μ^\ast(A_1)+μ^\ast(A_2)+μ^\ast(A_3')$となる。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E5%8F%AF%E6%B8%AC%E9%9B%86%E5%90%88%E3%81%AE%E6%80%A7%E8%B3%AA">ルベーグ可測集合の性質</h2>
<p>ルベーグ可測集合及び$\mathfrak{M}$の基本性質として以下が成り立つ。</p>
<ul>
<li>$A\in \mathfrak{M}$ならば$A^c\in \mathfrak{M}$</li>
<li>空集合$\varnothing$は$\varnothing\in\mathfrak{M}$</li>
<li>ルベーグ集合列を$\lbrace E_j\rbrace ^∞_{j=1}$とすると、$\bigcup_{j=1}^∞E_j$もルベーグ可測集合である。(つまりルベーグ可測集合の可算無限和集合もルベーグ可測集合)</li>
</ul>
<p>また、以下の可算加法性が成り立つ。</p>
<p>$A_1,A_2,\cdots\in\mathfrak{M}$は互いに素であるとする。この時、任意の$B\in \mathfrak{P}(R^n)$に対し、
$$
μ^\ast(B\cap \bigcup_{i=1}^∞A_i)=\sum_{i=1}^∞μ^\ast(B\cap A_i)
$$
が成り立つ。特に$B=R^n$とすれば
$$
μ^\ast(\bigcup_{i=1}^∞A_i)=\sum_{i=1}^∞μ^\ast(A_i)
$$</p>
<p>なる完全加法性が成り立つ。また、空集合はルベーグ可測集合なのでi=n以降を空集合とすれば有限加法性も成り立つのは明らかだろう。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E6%B8%AC%E5%BA%A6">ルベーグ測度</h2>
<p>ルベーグ外測度の始域を$\mathfrak{M}$にした写像$μ$を <strong>ルベーグ測度</strong> という。
$$
μ:\mathfrak{M}→R,\quad μ(A)=μ^\ast(A)
$$</p>
<h2 id="%CF%83-%E9%9B%86%E5%90%88%E4%BD%93%E6%9C%89%E9%99%90%E5%8A%A0%E6%B3%95%E6%97%8F%E5%8F%AF%E6%B8%AC%E7%A9%BA%E9%96%93">σ-集合体、有限加法族、可測空間</h2>
<p>集合XとXの部分集合の族$\mathfrak{M}$が以下の性質を満たすとき、$\mathfrak{M}$を <strong>σ-集合体</strong> 、 <strong>σ-代数</strong> 、 <strong>σ-加法族</strong> 、 <strong>完全加法族</strong> などという。また$(X,\mathfrak{M})$を <strong>可測空間</strong> と呼ぶ。</p>
<ol>
<li>$\varnothing\in\mathfrak{M}$</li>
<li>$A\in\mathfrak{M}$ならば$A^c\in\mathfrak{M}$</li>
<li>$A_1,A_2,\cdots \in\mathfrak{M}$ならば、$\bigcup_{j=1}^∞A_j\in \mathfrak{M}$</li>
</ol>
<p>また、条件2,3より$A_1,A_2,\cdots \in\mathfrak{M}$ならば、$\bigcap_{j=1}^∞A_j\in \mathfrak{M}$も示される。</p>
<p>ここで条件3を緩くして∞をnに変えたもの条件3'とする。条件1、2、3'を満たす$\mathfrak{M}$を <strong>有限加法族</strong> と呼ぶ。条件1と条件3より明らかにσ-集合体は有限加法族である。</p>
<h2 id="%CF%83-%E5%8A%A0%E6%B3%95%E6%97%8F%E3%81%AE%E7%94%9F%E6%88%90">σ-加法族の生成</h2>
<p>集合XとXの部分集合の族を$F$とする。Fを含むようなσ-加法族全体の集合を$\mathfrak{F}$とすると$F_0=\bigcap_{f\in \mathfrak{F}}f$とすればこれは最小のσ-加法族となる。これを$σ(F)$と書き、Fによって生成されるσ-加法族という。</p>
<h2 id="%E3%83%9C%E3%83%AC%E3%83%AB%E9%9B%86%E5%90%88%E3%83%9C%E3%83%AC%E3%83%AB%E9%9B%86%E5%90%88%E6%97%8F">ボレル集合、ボレル集合族</h2>
<p>$(X,\mathfrak{O})$を位相空間とする。$\mathfrak{O}$で生成されるσ-加法族を <strong>ボレル集合族</strong> といい、$B(X)=σ(\mathfrak{O})$と書く。$B(X)$の元を <strong>ボレル集合</strong> という。ただし、基本的に脈略なくボレル集合族といったらユークリッド空間の通常の位相から生成されるσ加法族と思っていい。</p>
<p>例えば以下はすべてボレル集合B(R)である。</p>
<ol>
<li>(a,b)</li>
<li>[a,b]</li>
<li>[a,b)</li>
<li>{a}</li>
<li>Q</li>
<li>R\Q</li>
</ol>
<p>など。証明は<a href="https://mathlandscape.com/borel-set/">こちら</a>にあるが感覚的にはまず開集合は即座にボレル集合なのは明らか。開集合の補集合もボレル集合でなければσ-加法族になれないので閉集合もボレル集合。あとは和集合や共通部分を取るなり(必要なら無限回)すれば雰囲気的には成り立つ。</p>
<p>また、$B(R)\subset \mathfrak{M}$であり、$(R,B(R))$は可測空間である。一応B(R)に含まれないが$\mathfrak{M}$には含まれる病的な可測集合Xもあるが、基本的に可測集合かどうかはボレル集合に含まれるかどうかを見ればいい。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E6%B8%AC%E5%BA%A6%E3%81%AE%E5%8D%98%E8%AA%BF%E6%80%A7">ルベーグ測度の単調性</h2>
<p>可測集合列$A_n$に対し、次の定理が成り立つ。</p>
<ol>
<li>$A_n\subset A_{n+1}$ならば
$$
μ(\bigcup <em>{n=1}^∞A_n)=\lim</em>{n→∞}μ(A_n)
$$</li>
<li>$A_{n+1}\subset A_{n}$かつ$μ(A_1)=∞$ならば
$$
μ(\bigcap_{n=1}^∞A_n)=\lim_{n→∞}μ(A_n)
$$</li>
</ol>
<h2 id="%E6%B8%AC%E5%BA%A6%E6%9C%89%E9%99%90%E5%8A%A0%E6%B3%95%E7%9A%84%E6%B8%AC%E5%BA%A6%E6%B8%AC%E5%BA%A6%E7%A9%BA%E9%96%93">測度、有限加法的測度、測度空間</h2>
<p>可測空間$(X,\mathfrak{M})$に写像$μ:\mathfrak{M}→R$が以下を満たすとき、μを <strong>測度</strong> といい、$(X,\mathfrak{M},μ)$を <strong>測度空間</strong> という。</p>
<ol>
<li>$μ(\varnothing)=0$</li>
<li>完全加法性を満たす。つまり、互いに素な集合の列$A_n\in\mathfrak{M}$に対し、$μ(\bigcup_n A_n)=\sum_nμ(A_n)$</li>
</ol>
<p>よってルベーグ測度を入れた空間$(R,\mathfrak{M},μ)$は測度空間である。</p>
<p>また、他にも測度が有限なら有限測度、測度が1以下しかとらないなら確率(測度)と呼ばれる。また上記の2つの公理より</p>
<p>$$
μ(A\cup B)=μ(A)+μ(B)-μ(A\cap B)
$$
が導かれる。</p>
<p>また、条件2を緩めて∞をnにしたものを満たす場合、 <strong>有限加法的測度</strong> という。ただし、測度→有限加法的測度は成り立つが、有限加法的測度→測度は成り立たないため、有限加法的測度は測度の名を冠するにふさわしくない。よって <strong>有限加法的集合関数</strong> と呼ばれる事もある。</p>
<h2 id="%E3%83%9B%E3%83%83%E3%83%97%E3%81%AE%E6%8B%A1%E5%BC%B5%E5%AE%9A%E7%90%86">ホップの拡張定理</h2>
<p>ホップの拡張定理はある条件下なら、ある測度が存在することを保証する定理である。</p>
<p>今、$(X,Σ_0,μ')$の$Σ_0$を <strong>有限加法族</strong> 、$μ':Σ_0→\bar A$を <strong>有限加法的測度</strong> とする。この$μ'$が$Σ_0$内の互いな素な集合列に対し完全加法性を満たすならば、σ加法族$Σ=σ(Σ_0)$上に測度$μ:Σ→\bar A$が存在する。さらに$μ$は定義域を$Σ$から$Σ_0$に制限した場合、$μ=μ'$となる。</p>
<p>つまり$(X,Σ,μ)$なる測度空間は存在し、さらに$μ$は$Σ_0$に制限した場合、$μ=μ'$</p>
<h2 id="%E6%8B%A1%E5%A4%A7%E5%AE%9F%E6%95%B0bar-r">拡大実数$\bar R$</h2>
<p>$R=(-∞,∞)$であるが拡大実数$\bar R$とは∞を認めた実数である。つまり$\bar R=R\cup \lbrace -∞,∞\rbrace$となる。</p>
<h2 id="%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0">可測関数</h2>
<p>可測空間$(X,\sum)、(Y,T)$に対し、写像$f:X→Y$が <strong>可測</strong> であるとは全ての$E\in T$の逆像$f^{-1}(E)$が$f^{-1}(E)\in\sum$になることを言う。</p>
<p>ここからは <strong>個人の見解</strong> だが、一応これが一番汎化させた表現になるはずだが、結構場所によって定義が違う(より特化した定義になっているところもある)。一般に可測関数と言ったら後述するボレル可測関数やルベーグ可測関数を指す場合もあり(f(x)&gt;aなる逆像で定義する奴)文脈を読み取る必要がおそらくある。特化させたものを定義としているものを2種類は今までで見た。中には$T$は意識せずに(暗黙的にボレル集合として扱ってる？)定義しているものもあり(つまりf(x)&gt;aなる逆像で定義する奴)一番いい方法は <strong>文脈から雰囲気で読みとり後は、あまり深く定義を考えすぎない事</strong> だと思う。もちろん厳密な議論が必要なら定義を考えよう。</p>
<h2 id="%E3%83%9C%E3%83%AC%E3%83%AB%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0">ボレル可測関数</h2>
<p>ボレル可測関数は以降出てこないので説明しなくてもいいのだが、ついでなので。</p>
<p>可測空間$(X,\sum)、(Y,T)$のσ加法族が共にボレル集合族ならばその可測関数を <strong>ボレル可測関数と呼ぶ</strong> 。ただし場合によっては後述するルベーグ可測関数と同じように
$$
\lbrace x\in X| f(x)&gt;a\rbrace \in B
$$
(Bはボレル集合族)で定義される場合もある。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0">(ルベーグ)可測関数</h2>
<p>ルベーグ可測関数とは、任意の可測空間からR上のボレル集合族への可測関数です。</p>
<p>つまり、$(R,\mathfrak{M})、(\bar R,B(\bar R))$の可測空間において、$X\in\mathfrak{M}$上の関数$f:X→\bar R$が <strong>(ルベーグ)可測関数</strong> であるとは、任意の$a\in R$に対して
$$
\lbrace x\in X| f(x)&gt;a\rbrace \in\mathfrak{M}
$$
であることを言う。また、この時$f$は$\mathfrak{M}$ <strong>可測</strong> とも呼ばれる。必要十分条件として任意のボレル集合$B\in B(R)$の逆像が$\mathfrak{M}$に含まれると言ってもいい。式にすると
$$
f^{-1}(B)=\lbrace x\in R| f(x)\in B\rbrace \in\mathfrak{M}
$$</p>
<p>となる。</p>
<p>また、σ-加法族の性質より$X^c$も$X^c\in\mathfrak{M}$なので、$f:X→\bar R$を拡張して$f':R→\bar R,f'(x)=f(x)(x\in X),f'(x)=0(x\in X^c)$とすればよって <strong>関数の定義域はRに限定しても可測性の一般性を失わない。</strong></p>
<p>なぜなら、$a&gt;0$ならば$\lbrace x\in X| f'(x)&gt;a\rbrace=\lbrace x\in X| f(x)&gt;a\rbrace$となり、$a\leqq 0$の時は$\lbrace x\in X| f'(x)&gt;a\rbrace=\lbrace x\in X| f(x)&gt;a\rbrace \cup X^c$となるがこれもσ-加法族の性質より$\lbrace x\in X| f(x)&gt;a\rbrace \in\mathfrak{M}$ならば$\lbrace x\in X| f'(x)&gt;a\rbrace\in\mathfrak{M}$となる為である。</p>
<p>ちなみに
$$
\lbrace x\in X| f(x)&gt;a\rbrace
$$
の$f(x)&gt;a$を$f(x)\geqq a,f(x)&lt;a,f(x)\leqq a$などに変えても同値である。</p>
<h2 id="%E3%83%9C%E3%83%AC%E3%83%AB%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0">ボレル可測関数とルベーグ可測関数</h2>
<p>ボレル可測関数$f_B$は$(R,B(R))、(R,B(R))$への写像
ルベーグ可測関数$f_L$は$(R,\mathfrak{M})、(\bar R,B(R))$への写像である。ここで$f_L\neq ±∞$とすれば$f_L$は$(R,\mathfrak{M})、( R,B(R))$への写像と見ても問題ない。(集合論的な言うなら終域を重視しない写像)</p>
<p>ルベーグ可測関数が$±∞$にならないとする。するとボレル可測関数ならばルベーグ可測関数なのはすぐに分かるだろう。逆は成り立たないのも明らかだろう。</p>
<h2 id="%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0%E3%81%AB%E3%82%88%E3%82%8A%E5%AE%9A%E7%BE%A9%E3%81%95%E3%82%8C%E3%82%8B%E9%96%A2%E6%95%B0%E3%81%AE%E5%8F%AF%E6%B8%AC%E6%80%A7">可測関数により定義される関数の可測性</h2>
<p>ここから可測関数といったらルベーグ可測関数のことを指すとする。f,gを可測関数とする。ここで関数の四則演算を$(f+g)(x):=f(x)+g(x)$のように定義すると以下の性質が成り立つ。</p>
<ul>
<li>kfのように定数倍しても可測関数。</li>
<li>関数f+gも可測関数</li>
<li>関数$f\cdot g$も可測関数</li>
<li>関数$\frac{f}{g}$も可測関数。ただし$g(x)\neq0$</li>
</ul>
<p>また、$f_+:=max(f(x),0)$と置き、これをfの <strong>正成分</strong> という。要は$f(x)$が０以上なら$f_+=f$でそうでないxについては$f_+=0$である。同様に$f_-$を関数$-f$の正成分を <strong>負成分</strong> という。以下の定理が成り立つ。</p>
<ul>
<li>fが可測関数なら、fの正成分及びfの負成分も可測関数。</li>
</ul>
<p>fの正成分及びfの負成分も可測関数なので$f_+f_-=|f|$より</p>
<ul>
<li>fが可測関数なら、$|f|$も可測関数。</li>
</ul>
<p>また、<strong>fが連続関数なら可測関数</strong>。</p>
<h2 id="%E3%81%84%E3%81%9F%E3%82%8B%E3%81%A8%E3%81%93%E3%82%8D%E3%81%A7%E7%AD%89%E3%81%97%E3%81%84">いたるところで等しい</h2>
<p>2つの関数f,gが <strong>いたるところで等しい</strong> とは
$$
μ^\ast(\lbrace x|f(x)\neq g(x)\rbrace)=0
$$
が成り立つ時をいい、fが可測関数ならgも可測関数になる。</p>
<h2 id="%E7%89%B9%E6%80%A7%E9%96%A2%E6%95%B0%E3%81%A8%E5%8D%98%E9%96%A2%E6%95%B0">特性関数と単関数</h2>
<p><strong>特性関数</strong> $χ_A(x)$とは$A\subset X$に対し、
$$
χ_A:X→R \quad χ_A(x)=1(x\in A),0(x\in A^c)
$$
なる関数を言う。</p>
<p><strong>単関数</strong> $s(x)$とは、関数sが互いに素な$A_1,\cdots ,A_N\subset X$に対し、
$$
s:X→R \quad s(x)=\sum_{i=1}^Na_iχ_{A_i}
$$
と表されることをいう。$A_i$に特に制限はないため、$s(x)$は一意には定まらないので注意。</p>
<p>定義より単関数が可測関数になるには任意の$i$に対し、
$$
\lbrace x\in X| f(x)=a_i\rbrace
$$
が可測集合になることを言う。</p>
<h2 id="%E9%9D%9E%E8%B2%A0%E5%80%A4%E5%8D%98%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E7%A9%8D%E5%88%86">非負値単関数のルベーグ積分</h2>
<p>非負値単関数$s(x)=\sum_{i=1}^Na_iχ_{A_i}$が可測関数の時、そのルベーグ積分は
$$
\int_As(x)dx=\sum_{i=1}^Na_i×μ(A_i)
$$
を可測単関数sのA上の <strong>ルベーグ積分</strong> という。ちなみに、積分の結果は拡張実数で扱われるため、∞を含む値も有効な結果として扱われます。ただし、拡張実数にはいくつかの演算規則があるので、注意が必要です。例えば、$0×∞=0$、$∞+∞=∞$、$∞-∞=not defined$などが挙げられます。また、$a_i×μ(A_i)&gt;0$から、シグマの中に$-∞$が含まれることはないので、可測単関数sの積分結果は必ず存在することになります。</p>
<h2 id="%E9%9D%9E%E8%B2%A0%E5%80%A4%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E7%A9%8D%E5%88%86">非負値可測関数のルベーグ積分</h2>
<p>非負値可測関数のルベーグ積分は、$f$を$A$上の関数としAを任意の$A_i(i=1,2,\cdots .n)$に直和分割する。$a_k:=inf_{x\subset A_k}(f(x))$とすると、
$$
\int_Af(x)dx:=sup(\sum_{i=1}^na_kμ(A_k))
$$</p>
<p>と定義される。</p>
<p>非負値可測関数$f$は、ある非負単関数列$\lbrace f_n\rbrace$が存在し、以下の定理が成り立つ。</p>
<ul>
<li>任意のnに対して$f_n$は可測関数</li>
<li>$\lbrace f_n\rbrace$は広義単調増加(ただしいたるところで等しい場合も広義単調増加と認める)</li>
<li>$\lim _{n→∞}f_n=f\quad a.e.$(a.e.とはいたるところで等しい場合の記号)</li>
</ul>
<p>が成り立つ。また、積分結果は単関数の表示形式によらない事が知られている。さらにファトゥの補題(後述する)と組み合わせれば
$$
\int_Af(x)dx=\lim_{n→∞}\int_Af_n(x)
$$
が成り立つ。</p>
<h2 id="%E5%8F%AF%E6%B8%AC%E9%96%A2%E6%95%B0%E3%81%AE%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E7%A9%8D%E5%88%86">可測関数のルベーグ積分</h2>
<p>可測関数$f$は可測な正成分と負成分によって$f=f_+-f_-$と分解出来る為、一般の可測関数の積分は以下のように定義される。
$$
\int_Af(x)dx=\int_Af_+(x)dx-\int_Af_-(x)dx
$$</p>
<p>よって積分結果は$\int_Af_+(x)dx\neq ∞$または$\int_Af_-(x)dx\neq ∞$となる場合に存在します。</p>
<h2 id="%E3%83%95%E3%82%A1%E3%83%88%E3%82%A5%E3%81%AE%E8%A3%9C%E9%A1%8C">ファトゥの補題</h2>
<p>非負可測関数列$\lbrace f_n\rbrace$に対し、
$$
\int(\liminf_{n→∞}f_n)dx\leqq\liminf_{n→∞}\int f_ndx
$$
が成り立つ。$\liminf_{n→∞}a_n$は$\inf(a_∞(x))$のことである。</p>
<h2 id="%E9%A0%85%E5%88%A5%E7%A9%8D%E5%88%86">項別積分</h2>
<p>非負可測関数列$\lbrace f_n\rbrace$とする。この時、
$$
\int\sum_{n=1}^∞f_ndx=\sum_{n=1}^∞\int f_ndx
$$
が成り立つ。ただし、$\sum_{n=1}^∞f_n$は収束する(拡大実数なので∞及び-∞も収束である。)か$∞-∞$領域の測度は0でなければ左辺の積分値は存在しないため、右辺も存在しなくなる。</p>
<p>また、より一般に可測関数列$\lbrace f_n\rbrace$とする。ここで
$$
\sum_{n=1}^∞\int |f_n|dx&lt;∞
$$
ならば積分結果は存在し、
$$
\int\sum_{n=1}^∞f_ndx=\sum_{n=1}^∞\int f_ndx
$$</p>
<h2 id="%E6%B8%AC%E5%BA%A6%E3%81%AE%E5%AE%8C%E5%82%99%E6%80%A7">測度の完備性</h2>
<p>測度空間$(X,\mathfrak{M},μ)$に対し、零集合$A$の任意の部分集合$A'$が零集合となる時、これを測度空間$(X,\mathfrak{M},μ)$が <strong>完備</strong> であるという。ただし、測度が定義されている時点で単調性($A \in \mathfrak{M},B\in\mathfrak{M},A \subset B →μ(A)\leqq μ(B)$)が成り立つため、 <strong>要は完備性とは零集合の任意の部分集合に測度が定義できるのか？と言っている。</strong></p>
<h2 id="%E3%83%9C%E3%83%AC%E3%83%AB%E9%9B%86%E5%90%88%E6%97%8F%E3%81%A8%E5%8F%AF%E6%B8%AC%E9%9B%86%E5%90%88%E6%97%8F">ボレル集合族と可測集合族</h2>
<p>以下$R$での話をするが$R^n$でも同じである。</p>
<p>まず正確には「$(R,B(R),μ)$ボレル集合族上のルベーグ測度」と「$(R,\mathfrak{M},μ)$ルベーグ可測集合族上のルベーグ測度」は異なるものである。なぜならルベーグ測度の定義域が違うからである。さらにこの違いによって完備性に影響が出てくる。具体的にはボレル集合族上のルベーグ測度は完備ではないがルベーグ可測集合族上のルベーグ測度は完備である。</p>
<h2 id="%E6%B8%AC%E5%BA%A6%E7%A9%BA%E9%96%93%E3%81%AE%E5%AE%8C%E5%82%99%E5%8C%96">測度空間の完備化</h2>
<p>完備ではない測度空間$(S,M,μ)$に対し新しく集合$\bar M$を
$$
\bar M=\lbrace B\cup Z| B\in M,Z\subset N,μ(N)=0 \rbrace
$$</p>
<p>とする。つまり零集合のすべての部分集合と集合Mの元の和も$M$に入れてるだけである。さらに$μ:\bar M→\bar R$として定義域を拡張してやれば$(S,\bar M,\bar μ)$は完備な測度空間である。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E6%B8%AC%E5%BA%A6%E3%81%AE%E5%AE%9A%E7%BE%A9%E6%96%B9%E6%B3%95">ルベーグ測度の定義方法</h2>
<p>今回はルベーグ外測度を定義し、そこからルベーグ可測集合なる概念を導入し、定義域を冪集合からルベーグ可測集合族$2^R→\mathfrak{M}$に狭めることでルベーグ測度の定義を行った。つまり測度空間$(R,\mathfrak{M},μ)$の定義を外測度及びルベーグ可測集合族により行った。</p>
<p>ここでもう一つの定義方法を紹介する。これを知ることでよりボレル集合族と可測集合族の違いがわかると思ったからである。</p>
<p>可測空間$(R,B(R))$において、測度$μ'((a,b])=b-a$なる測度が一意に存在する。証明はホップの拡張定理を用いて行う。これで測度空間$(R,B(R),μ')$が定まった。さらに測度空間の完備化を行うことで$(R,B(R)',μ'')$となる。これは実は外測度より定義した$(R,\mathfrak{M},μ)$と一致する。</p>
<h2 id="%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B0%E5%8F%AF%E6%B8%AC%E3%81%A7%E3%81%AA%E3%81%84%E4%BE%8B">ルベーグ可測でない例</h2>
<p>ルベーグ可測集合でない例の方が圧倒的に分かりにくいが実は非可算個存在する。なのにもかかわらずなぜ見つけられないかというと選択公理が支配的だからである(らしい。ソロヴェイの定理より。)。正直ソロヴェイの定理は今の自分には手に負えないのでこれは認めることとする。選択公理を用いた具体例は&quot;測度、確率、ルベーグ積分(著:原)&quot;のP32~P33にのっている。同値類さへ知っていれば簡単に分かるので見てみよう。</p>

</article>
</body>
<script>
	elements = document.getElementsByTagName("h2");
	table_of_contents = document.createElement("ul");
	h2=document.createElement("h2");
	h2.textContent="目次"
	table_of_contents.appendChild(h2)
	for (  var i = 0;  i < elements.length;  i++  ) {
		console.log(elements[ i ]);
		const newElement_li = document.createElement("li");
		const newElement_a = document.createElement("a");
		newElement_a.href="#"+elements[ i ].id;
		newElement_a.textContent = elements[ i ].textContent;
		newElement_li.appendChild(newElement_a);
		table_of_contents.appendChild(newElement_li);
		
	}
	parents=document.getElementsByClassName("markdown-body")[0];
	h1 = document.getElementsByTagName("h1")[0];
	parents.insertBefore(table_of_contents, h1.nextSibling)
</script>
</html>